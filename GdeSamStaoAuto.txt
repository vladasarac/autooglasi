napravio instalaciju laravela 5.2 komandom " composer create-project --prefer-dist laravel/laravel auto 5.2.29" i zatim napravio v-host tj u fajlu httpd-vhosts.conf iz foldera -
-'C:\xampp\apache\conf\extra' dodao na dnu 
<VirtualHost *:80>
    DocumentRoot "C:/xampp/htdocs/auto/public"
    ServerName auto.dev
</VirtualHost>
i u fajlu hosts iz foldera 'C:\Windows\System32\drivers\etc' na dnu dodao 
127.0.0.1       auto.dev 
tako da sada u URL kucam auto.dev da pristupim aplikaciji...
Da bih na ostalim uredjajima u kuci mogao da vidim sajt u fajlu HOSTS iz 'C:\Windows\System32\drivers\etc' sam na dnu dodao 
192.168.0.10 C:/xampp/htdocs/auto/public
a u fajlu httpd-vhosts.conf iz C:\xampp\apache\conf\extra sam na dnu dodao 
<VirtualHost *:80>
    DocumentRoot "C:/xampp/htdocs/auto/public"
    ServerName 192.168.0.10
</VirtualHost>
tako da sada kad na nekom drugom uredjaju ukucam ip adresu desktopa na kom je XAMP (tj. 192.168.0.10 je sad a ako ga promeni onda mora i ovde da se menja) on 
-direktno ide na auto.dev 

VAZNO VAZNO VAZNO VAZNO
Google je menjao nesto oko sigurnosti pa sam morao da promenim u fajlu ' HOSTS ' iz ' C:\Windows\System32\drivers\etc ' i u ' httpd-vhosts.conf ' iz 
 - ' C:\xampp\apache\conf\extra '  auto.dev u auto.localhost, isto sam uradio i za neke druge laravel aplikacije

//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

izmenio sam migraciju za 'users' tabelu tj dodao sam neke kolone, tacnije:
public function up() {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->string('password');
            $table->enum('role', ['admin', 'author'])->default('author');
            $table->integer('aktivan')->default(0);
            $table->string('telefon', 20)->nullable()->unique();
            $table->integer('brojoglasa')->default(0);
            $table->rememberToken();
            $table->timestamps();
        });
}
napravio sam bazu 'auto' i povezao je sa aplikacijom u .env fajlu i zatim sam migrirao, napravio sam prvog usera(Vlada Sarac, vladasarac@hotmail.com, pikolo, ...) i dao 
-sam mu admin rolu
Layout app.blade.php koji je napravio laravel sam preimenovao u app1.blade.php a ja sam napravio novi app.blade.php u koji ubacujem HTML iz fajlova koje sam skinuo sa 
- neta tj sa URL - https://bootstrapthemes.co/item/jonaki-job-board-bootstrap-template/ 
u public folder aplikacije ubacujem css, js, images i slicno, i sada u novi app.blade.php layout kopiram sadrzaj index.html fajla koji sam skinuo sa neta(tacnije samo pocetak do
-kraja navigacije i kraj sa linkovima ka js fajlovima)
Tu je bio mali problem posto se u google chrome-u zaglupljivala navigacija pa je imala desno marginu od jedno 1000px pa sam na dnu layouta dodao ovo -
<script>
  //ja dodao da bi nav imao marginu sa desne strane od 7 px
  $(window).load(function(){
    setTimeout(function() {
      $('.navbar').css('margin-right', '7px');
    }, 3000);          
  });
</script>  
tako da sada kad posle 3 sec posle ucitavanja stranice doda ovu desnu marginu navigaciji nestane ta ogromna margina koju je pre dodavao
Malo menjam html u register.blade.php(zapravo sam originalni register preimenovao u register1.blade.php a u novi sam ga copy-pasteovao pa sam menjao), dodajem polje-
-telefon u formi za registraciju posto ce se u 'users' tabelu upisivati i telefon korisnika(treba tu jos dodati i adresu i mapu i logo i slicno ako je korisnik pravno lice...), menja sam-
-kontroler AuthController.php iz 'auto\app\Http\Controllers\Auth' posto se pri registraciji upisuje i telefon korisnika, takodje sam u User.php model dodao u fillable array i kolone-
-koje sam dodao u 'users' tabelu a koje nisu tu po difoltu
protected $fillable = [  'name', 'email', 'password', 'role', 'aktivan', 'telefon', 'brojoglasa'  ]; ,  ovo sam dodao u AuthControler
protected function validator(array $data){
        return Validator::make($data, [
            'name' => 'required|max:255',
            'email' => 'required|email|max:255|unique:users',
            'password' => 'required|min:6|confirmed',
            'telefon' => 'required|digits_between:9,20' // ja dodo posto se pri registraciji upisuje i telefon
        ]);
}
i zatim u create( ) metod 
protected function create(array $data){
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => bcrypt($data['password']),
            'telefon' => $data['telefon'] //ja dodo posto se pri registraciji upisuje i telefon
        ]); 
}
Takodje pravim novi vju login.blade.php kji malo menjam da bi bio u skladu sa css-om koji sam skinuo sa interneta, u app.blade.php layoutu menjam da u zavisnosti od toga -
-da li je korisnik uogovan ili nije i da li je admin ili author ima drugaciju navigaciju sa drugacijim linkovima(za sada su sve satro linkovi...)
Napravio sam migraciju za tabelu 'marke' komandom "php artisan make:model Marka --migration" u migraciju dodajem kolonu name u koju ce admin moci da upise imena ma-
-rki automobila (zbog laravela tabela ce se zvati 'markas' da na bi komplikovao pa prepravljao ...) takodje je napravljan i model Marka.php i njemu u $fillable dodajem 'name' da-
-bi ta kolona mogla da se popunjava
public function up(){
        Schema::create('markas', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name')->unique();
            $table->string('logo')->nullable();  //kolona u kojoj ce biti href ka images folderu u kom ce biti slike logo-a automobila
            $table->timestamps();
        });
}
Takodje pravim kontroler za 'markas' tabelu komandom "php artisan make:controller MarkaController"
Pravim folder 'admin' u 'auto\resources\views' u kom ce biti vjuovi za admina i u njemu vju dodajmarku.blade.php(na kom jos treba raditi tj napraviti formu koja gadja store( ) me-
-tod MarkaControllera koji ce u 'markas' tabelu upisivati novi red)
Pravim u routes.php rutu '/dodajmarku' koja gadja index( ) metod MarkaControllera - Route::get('/dodajmarke', 'MarkaController@index');
U MarkaControlleru u __constructu kazem da je kontroler u auth middleware-u i pravim metod index( ) koji ucitava vju dodajmarku.blade.php 
//samo autorizovani tj ulogovani useri imaju pristup metodima ovog kotrolera
public function __construct(){
  $this->middleware('auth');
}
//metod prikazuje vju dodajmarku.blade.php iz 'auto\resources\views\admin' u kom je forma za dodavanje marki u 'markas' tabelu
public function index(Request $request){
  if($request->user()->is_admin()){	//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    return view('admin.dodajmarku');// ako jeste saljemo ga na vju dodajmarku.blade.php
  }else{ //ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
Sada pravim admin panel koji ce biti glavna adminova stranica sa koje ce ici na druge stranice za administrieranje sajta, pravim vju adminpanel.blade.php u folderu -
-'auto\resources\views\admin', takodje pravim AdminController.php komandom "php artisan make:controller AdminController" i rutu koja gadja njegov index( ) metod koji ce ici
-na ovaj vju - Route::get('/adminpanel', 'AdminController@index'); U AdminControlleru dodajem __construct u kom pise da je kontroler u auth middleware-u tako da samo ulog-
-ovani useri mogu da prckaju po metodima... Zatim pravim index( ) koji proverava da li je user admin i ako jeste salje ga na vju adminpanel.blade.php
public function index(Request $request){
  if($request->user()->is_admin()){	//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    return view('admin.adminpanel');	// ako jeste saljemo ga na vju adminpanel.blade.php
  }else{ //ako nije admin saljemo ga na '/'
    return redirect('/');
  }	 	
}
adminpanel.blade.php takodje extenduej app.blade.php samio sto dole u @section content ima div-ove koji na klik idu na odredjene rute, za sada prvi div koji se klikne ide na -
-rutu /dodajmarke koja ide na vju dodajmarke.blade.php(tj na index( ) metod MarkaControllera) koji sluzi za dodavanje marki i modela automobila
Pravim formu za dodavanje marke i logo-a automobila u dodajmarke.blade.php, gadja kad se sabmituje store( ) metod MarkaControllera, Dodao sam u dodajmarku.blade.php
-da je forma u div-u .formadodajmarku koji je nevidljiv dok se ne klikne na naslov Dodaj Marke Automobila(hendler za to je u fajlu dodajmarke.js koji je u 'auto\public\js\autojq'-
-pogledaj zakomentarisano je) takodje sam pre ovoga skinuo Laravelov paket za resize slika(paket i uputstvo za upotyrebu istog sam nasao na URL-
https://stackoverflow.com/questions/40358510/resize-image-in-laravel-5-2, prvo komanda "composer require intervention/image", pa se onda u app.php iz config dodaju prov-
-ideri aliasses u arraye koji tamo vec postoje(provider - Intervention\Image\ImageServiceProvider::class, alias-'Image' => Intervention\Image\Facades\Image::class) i onda sam
na vrhu MarkaControlera uvezao library - use Intervention\Image\ImageManagerStatic as Image; i koristim ga u metodu store( ) koji upisuje novu marku u 'markas' tabelu i pre
-toga resize-uje sliku tj logo koji uploadujem i cuva ga u folderu 'auto\public\img\autologo'), vju je zakomentarisan(tj forma za dodavanje nove marke), takodje store( ) metod -
- MarkaControllera tako da ih necu ovde kopirati posto su poveliki...
Sada cu u dodajmarku.blade.php dodati formu za unos modela odredjene marke u 'modelis' tabelu(tako se zove posto se model zove Modeli.php), prvo pravim model i migra-
-ciju komandom " php artisan make:model Modeli --migration", ovo dodajem u migraciju, tj dodajem kolone marka_id koja ce biti foreign key na id kolonu 'markas' tabele
Schema::create('modelis', function (Blueprint $table) {
   $table->increments('id');
   $table->integer('marka_id')->unsigned();
   $table->foreign('marka_id')->references('id')->on('markas')->onDelete('cascade');
   $table->string('ime')->unique();
   $table->timestamps();
});
Pravim u modelima Marka.php i Modeli.php funkcije kojima pravim one-to-many relaciju izmedju 'markas' i 'modelis' tabela Modeli.php-
//one-to-many relacija sa 'markas' tabelom posto model pripada samo jednoj marki
public function marka(){
      return $this->belongsTo('App\Marka', 'marka_id');	
}
Marka.php
//one-to-many relacija sa 'modelis' tabelom, posto marka ima vise modela
public function modelis(){
      return $this->hasMany('App\Modeli', 'marka_id');  
} 
U vjuu dodajmarku.blade.php pravim novu formu za unos modela odredjene marke forma je takodje u divu koji po difoltu ima atribut hiiden='true' i kad se klikne naslov dodaj - 
-modele marke hendler u dodajmarke.js uklanja to i div postaje vidljiv, u formi imamo select u kom se bira kojoj ce se marki dodavati model i ima slika logoa marke koja ce se me-
-njati u zavisnosti od marke(to ce biti napravljeno takodje u dodajmarke.js) i input za ime modela, user mora odabrati marku i upisati ime novog modela inace validacija u kontr-
-oleru(MarkaCOntroller) nece proci. pravim rutu 
//ruta gadja storemodel() metod MarkaControllera kad se sabmituje forma za dodavanje novog modela neke marke u dodajmarke.blade.php
Route::post('/storemodel', 'MarkaController@storemodel');
pravim storemodel( ) metod u MarkaControlleru
//metod se poziva kad se u dodajmarku.blade.php sabmituje forma za dodavanje novog modela neke marke, zatim ovaj metod upisuje red u 'modelis' tabelu
public function storemodel(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    //prvo validacija
    $this->validate($request, array(
      'imemodela' => 'required|max:255', // polje imemodela je obavezno i maksimalno 255 karaktera
      'imemarke2' => 'required' 
    ));
    $model = new Modeli();
    $model->marka_id = $request->get('imemarke2');//uzimamo id marke(id kolona 'markas' tabele, to je select polje u formi za dodavanje modela)
    $model->ime = $request->get('imemodela');//uzimamo ime koje je uneto u input u formi 
    $model->save(); //upisujemo red u 'modelis' tabelu
    $idmarke = $request->get('imemarke2');//sada vadimo iz 'markas' kolone ime marke kojoj smo dodali model da bi success poruka bila lepsa...
    $marka2 = DB::table('markas')->where('id', $idmarke)->value('name');
    $successmodel = '<img src="img/greenclose.png" class="pull-right closebtnsuccess">Uspesno ste uneli model: '.$request->get('imemodela').' Za marku: '.$marka2;//pravimo succes message
    Session::flash('successmodel', $successmodel);//ubacujemo success message u sesiju
    //vadimo potrebne vrednosti iz 'markas' tabele tj logo, id i ime marke ciji smo model menjali da bi vju dodajmarke.blade.php znao da treba
    //da opet prikaze otvoren div sa formom za unos modela za istu tu marku i njen logo
    $markaime = $marka2;
    $markalogo2 = DB::table('markas')->where('id', $idmarke)->value('logo');
    $markaid2 = DB::table('markas')->where('id', $idmarke)->value('id');
    $marke = Marka::all()->sortBy("name");
    //pozivamo vju dodajmarke.blade.php i saljemo mu potrebne variable
    return view('admin.dodajmarku')->withMarke($marke)->withMarkaime($markaime)->withMarkalogo2($markalogo2)->withMarkaid2($markaid2);
  }else{//ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
Postoje u dodajmarku.js hendleri za ovo ali ih necu ovde kopirati, zakomentarisano je 
Sada pravim funkcionalnost editovanja vec unetih modela marke, kada u formi za dodavanje modela user odabere neku marku pojavice se div koji ce kad se klikne ispod prika
-zati sve do sada unete modele i klikom na njih ce se pojaviti input u koji ce user moci da unese prepravku, prikaz div .prikazimodelemarke je u hendleru za promenu select-a -
-u formi za dodavanje novog modela marke u dodajmarke.js, tj kad user odabere marku kojoj dodaje model odmah se pojavljuje div koji nudi prikaz modela
Znaci kad kliknemo div .prikazimodelemarke njegov hendler iz dodajmarke.js salje AJAX metodu prikazimodele( ) MarkaControllera koji vadi sve modele marke ciji je id stigao
-AJAXOM preko rute 'prikazimodele' i vraca JSON-a hendleru koji to prikazuje kao <ul> u divu <modeli> koji je izgenerisan ispod diva .prikazimodelemarke, nista novo ali ma-
-lo zapetljano pogledaj hendlere u dodajmarke.js zakomentarisano je 
VAZNO u folder 'C:\xampp\htdocs\auto\public\fonts' sam dodao fajlove za glyphicons(pocinju sve sa Glyphicon) ako budu u buducnosti pravile neke probleme zakomentarisi
ovo sam dodao posto ovaj css koji sam skinuo sa neta nije imao glyphicons po difoltu 
u listi koja prikazuje sve do sada unete modele neke marke postoji pored svakog modela i ikona za edit(.editmodel) kad se klikne hendler za klik na ikonu generise formu u koju
- se moze upisati novo ime modela, kad se ta forma sabmituje hendler za klik na submit btn #izmenimodel salje AJAX izmenimodel( ) metodu MarkaControllera u kom stizu  -
- idmodela koji se edituje i novo ime modela to sve ide preko rute 'izmenimodel'
Route::post('/izmenimodel', [
  'uses' => 'MarkaController@izmenimodel',
  'as' => 'izmenimodel'
]);
metod izmenimodel( ) MarkaControllera
//metod za editovanje modela, poziva se kad se u dodajmarku.blade.php sabmituje forma za editovanje modela koja je vidljiva kad kliknemo na -
//-ikonicu edit pored nekog modela(modeli su vidljivi u listi ispod forme za dodavanje novog modela marke), stize AJAX iz dodajmarke.js tj iz
//-hendlera za klik na btn #izmenimodel
public function izmenimodel(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    $staroimemodela = $request['staroimemodela'];//uzimamo staro ime modela koji se edituje(stigao AJAX-om)
    $idmodelazaedit = $request['idmodelazaedit'];//uzimamo id modela koji se edituje(stigao AJAX-om)
    $modelzaedit = Modeli::where('id', $idmodelazaedit)->first();//nalazimo u 'modelis' tabeli model za editovanje po id koji je stigao
    $modelzaedit->ime = $request['novoimemodela'];//prepravljamo ime kolonu novim imenom koje je stiglo AJAX-om
    $modelzaedit->save();//cuvamo promenu u 'miodelis' tabeli
    //takodje u 'oglasis' tabeli menjamo u koloni model ime modela do sada unetim oglasima koji su ovaj model
    Oglasi::where('model', $staroimemodela)->update(['model' => $request['novoimemodela']]);
    return response()->json(['modelzaedit' => $modelzaedit]);//vracamo odgovor hendleru u dodajmarke.js koji je poslao request 
  }else{//ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
Tako da sada user ispod forme za dodavanje modela marke u dodajmarke.blade.js ima mogucnost da vidi i edituje do sada unete modele marke koju je odabrao u <select>-u
- u formi za dodavanje novog modela marke
Brisanje unetog  modela
Pored ikone za edit modela dodajem i ikonu za brisanje modela(znaci kad hendler za klik na div .prikazimodelemarke generise ul u kom su imena modela ispod svakog su i iko-
-na za edit i sada i za brisanje tj glyphicone), klasa je .deletemodel i pravim hendler za klik na tu klasu u dodajmarke.js koji ce slati AJAX metodu deletemodel( ) MarkaControllera
pravim rutu preko koje ce hendler iz dodajmarke.js koji hendluje klik na btn tj glyphicon .deletemodel slati AJAX metodu deletemodel( ) MarkaControllera
Route::post('/deletemodel', [
  'uses' => 'MarkaController@deletemodel',
  'as' => 'deletemodel'
]);
Pravim u MarkaControlleru metod deletemodela( ) koji ce brisati model kad mu hendler za klik na .deletemodel posalje AJAX
//kad se u dodajmarku.blade.php u ul koja prikazuje modele neke marke pored nekog modela klikne btn tj glyphicon za trash preko rute /deletemodel
//stize ovde AJAX u kom je id modela za brisanje kog ovaj metod brise
public function deletemodel(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    $idmodelazdelete = $request['idmodelazdelete'];//uzimamo id modela koji se brise(stigao AJAX-om)
    $modelazdelete = Modeli::where('id', $idmodelazdelete)->first();//nalazimo u 'modelis' tabeli model za brisanje po id koji je stigao
    $deleted = $modelazdelete->delete();
  //vracamo odgovor hendleru u dodajmarke.js koji je poslao request, ako je uspesno obrisao vrednost $deleted varijable je true
    return response()->json(['deleted' => $deleted]);
  }else{//ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
hendler iz dodajmarke.js necu kopirati, zakomentarisan je ali on znaci uzima id modela za brisanje iz atributa idmodela btn-a tj glyphicona za brisanje nekog modela i salje ga 
-AJAX-om u deletemodel( ) metod MarkaControllera koji brise model i vraca varijablu $deleted koja ima vrednost true ako je model uspesno obrisan iz 'modelis' tabele i onda 
-hendler proverava da li je vreednost vracene varijable true i ako jeste iz ul koja prikazuje modele neke marke brise li kom je id jednak id-u obrisanog modela tj brise i iz vjua 
-obrisani model
Dodajem u dodajmarke.js da kad se selectuje neka marka u formi za dodavanje modela ispod sekcije koja prikazuje do sada unete modele odabrane marke pojavi div 
-.editmarke ciji ce hendler koji cu napraviti takodje u dodajmarke.js prikazivati formu za editovanje te marke koju smo odabrali
pravim hendler za div .editmarke u dodajmarke.js koji generise formu za editovanje unete marke i ima polje za unos novog imena i logo-a i ispod je forma za brisanje marke koja 
se sastoji samo od btn-a 'Obrisi Marku'
pravim rutu '/izmenimarku' koja ce gadjati izmenimarku( ) metod MarkaControllera kad se sabmituje forma za editovanje marke 
//ruta se koristi kad se sabmituje forma za edit neke marke u dodajmarke.blade.php, ide na metod izmenimarku() MarkaControllera
Route::post('/izmenimarku', [
  'uses' => 'MarkaController@izmenimarku',
  'as' => 'izmenimarku'
]);
Pravim metod izmenimarku( ) u MarkaControlleru koji se poziva kad se sabmituje forma za edit marke u dodajmarku.blade.php koju generise hendler za klik na div .editmarke
- iz dodajmarke.js
//metod koji radi update 'markas' tabele i takodje rename-uje logo marke ili brise stari i uploaduje novi u 'public/img/autologo' folder ako je 
//admin menjao sliku logo-a marke, sve ovo kad se sabmituje forma za editovanje marke u dodajmarke.blade.php(forma se generise u dodajmarke.js
//tj hendler za klik na div .editmarke)
public function izmenimarku(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    //prvo validacija
    $this->validate($request, array(
      'novoimemarke' => 'required|max:255' // polje imemarke je obavezno i maksimalno 255 karaktera 
    ));
    //od novog imena marke pravimo ime za kolonu logo i za novu sliku tj logo
    $novilogo = str_slug($request->get('novoimemarke')).'.png';
    $marka = Marka::find($request->get('idmarke'));//nalazimo u 'markas' tabeli marku koju editujemo po id koloni
    $marka->name = $request->get('novoimemarke');//uzimamo novo ime marke koju je user uneo u formu to ide u name kolonu 'markas' tabele
    $marka->logo = $novilogo;//poso je novo ime moramo menjati i logo kolonu
    if($request->file('novilogo')){//ako je admin uploadovao novu sliku tj logo
      //brisemo stari logo, ime starog logoa je doslo u requestu posto u hidden polju forme ima upisano staro ime logoa
      unlink('img/autologo/' . $request->get('starilogo'));
      $image = $request->file('novilogo');//uzimamo sliku koju je user uploadovao
      $fileName = str_slug($request->get('novoimemarke')).'.png'; // napravi ime slike(slug od imena marke)
      $image_resize = Image::make($image->getRealPath());//koristeci Intervention\Image libratry resize-ujemo sliku
      $image_resize->resize(100, 100);
      $image_resize->save(public_path('img/autologo/' . $fileName));//cuvamo sliku tj logo u folderu 'auto\public\img\autologo'
      $marka->logo = $fileName;//ime slike upisujemo u logo kolonu 'markas' tabele
    }else{//ako admin nije menjao sliku onda samo rename-ujemo onu koja vec postoji
      rename('img/autologo/' . $request->get('starilogo'), 'img/autologo/' . $novilogo);
    }    
    $marka->save();//cuvamo userov unos u tabelu
    //takodje u 'oglasis' tabeli menjamo u koloni marka ime mare do sada unetim oglasima  
    Oglasi::where('marka', $request->get('staroime'))->update(['marka' => $request->get('novoimemarke')]);
    $novoime = $request->get('novoimemarke');//ovde pravimo success poruku koju ubacujemo u Session da bi je vju prikazao
    $staroime = $request->get('staroime');
    $successizmena = 'Uspesno ste izmenili marku: '.$staroime.' u '.$novoime.'<br><img src="img/autologo/'.$novilogo.'?vreme='.date('Y-m-d H:i:s').'">';
    Session::flash('successizmena', $successizmena);
    return redirect()->back();//vracamo se na dodajmarku.blade.php sa success porukom u sesiji
  }else{//ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
pravim rutu '/obrisimarku' koja ce gadjati obrisimarku( ) metod MarkaControllera kad se sabmituje forma za brisanje marke 
//ruta se koristi kad se sabmituje forma za brisanje neke marke u dodajmarke.blade.php, ide na metod obrisimarku() MarkaControllera
Route::post('/obrisimarku', [
  'uses' => 'MarkaController@obrisimarku',
  'as' => 'obrisimarku'
]);
U MarkaControlleru pravim metod obrisimarku( ) koji brise marku koju admin zeli da obrise, brise logo iz '/public/img/autologo' i takodje iz 'modelis' tabele brise svwe modele ma
-rke koju brisemo(to radi laravel po automatizmu)
//kad se sabmituje forma za brisanje marke u dodajmarke.blade.php koja je izgenerisana u hendleru za klik na div .editmarke u dodajmarke.js
//metod brise marku iz 'markas' tabele, brise logo marke iz foldera '\public\img\autologo' i takodje iz 'modelis' tabele brise sve modele marke
//koju brisemo
public function obrisimarku(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    $idmarke = $request->get('idmarkebrisanje');//uzimamo id marke koju brisemo koji je stigao kad je sabmitovana forma
    $marka = Marka::find($idmarke);//u 'markas' tabeli nalazimo marku koju zelimo da brisemo
    $ime = $marka->name;//uzimamo ime marke da bi napravili success message
    if($marka){//ako nadje marku brisemo je iz 'markas' tabele i brisemo logo
      $marka->delete();
      unlink('img/autologo/' . $request->get('starilogobrisanje'));
    }else{
      return redirect()->back();
    }//pravimo success message
    $successbrisanje = 'Uspesno ste obrisali marku '.$ime.'!';
    Session::flash('successbrisanje', $successbrisanje);
    return redirect()->back();
  }else{//ako user koji poziva metod nije admin saljemo ga na '/'
    return redirect('/');
  }
}


Dodao sam u formu za registraciju u register.blade.php polje za unos grada u kom zivi user i takodje u AuthControlleru sam dodao da prilikom kreiranja usera upise i to polje u -
-'users' tabelu, polje u formi je obavezno tako da nece proci validacija u AuthControlleru ako ga user ne popuni, postoji array gradovi u register.blade.php koji sam ja dodao-
@php
  $gradovi = ["Aleksinac", "Arandelovac","Aleksandrovac","Beograd","Bor","Backa Palanka","Backa Topola","Bogatic","Bujanovac","Becej", "Novi Sad","Nis","Kragujevac"];    
 @endphp
- koji jos treba popuniti , pre svega ovoga sam komandom "php artisan make:migration add_grad_to_users_table --table=users" napravio migraciju za dodavanje kolone grad-
-'users' tabeli, u up( ) metod sam upisao -
//dodavanje kolone grad 'users' tabeli
Schema::table('users', function (Blueprint $table) {
          $table->string('grad')->nullable()->after('email');
});
tako da sada user mora pri registraciji navesti grad iz kog je, 
Dodavanje aktivacionog maila pri registraciji novog usera, prvo u 'users' tabelu dodajem kolonu verifikacija koja je po difoltu NULL ali kad se user registruje create( ) metod -
-AuthControllera generise se random string od 30 karaktera i upisuje u tu kolonu zatim se useru salje email koji sadrzi link koji ima argument verification a koji je zapravo taj string
Kada user klikne link u emailu ide na aktivacija( ) metod UsersControllera koji menja kolonu aktivan 'users' tabele iz NULL u 1 i user je aktivan
create( ) metod AuthControllera
protected function create(array $data){   
        //poruka koja ce se prikazati novo registrovanom useru 
        $success = "Registrovali ste se uspesno. Obavezno je aktivirati nalog. Na vasu email adresu poslat je aktivacioni email.";
        Session::flash('success', $success);
        //uzimamo ime user (ovo nam treba za aktivacioni mail koji mu saljemo)
        $name = $data['name'];
        //uzimamo email usera (ovo nam treba za aktivacioni mail koji mu saljemo)
        $useremail = $data['email'];
        //pravimo code koji cemo upisati u kolonu verification 'users' tabele a takodje mu saljemo taj kod na email
        $verification_code = str_random(30);
        // array koji cemo poslati u vju 'registracija.blade.php' iz 'auto\resources\views\email' koji ce zapravo biti email
        $data1 = array(
          'subject' => "Potvrda Registracije auto.dev",
          // VAZNO ne sme se dati naziv kljucu 'message' zato sto je to laravelova zasticena varijabla tako da cemo mi message zvati bodyMessage
          'bodyMessage' => "Uspesna registracija",
          'user' => $name,//saljemu u vju koji je mail i ime i emial usera da bi ih ubacili u sadrzaj maila da bi admin znao od koga je mail
          'useremail' => $useremail,
          'verification' => $verification_code//verifikacioni kod koji ce biti dodat linku koji user treba da klikne
        ); 
        //saljemo mail useru koristeci vju 'registracija.blade.php' iz 'auto\resources\views\email'
        Mail::send('email.registracija', $data1, function($message) use ($data1){
          $message->from('kantarion35@gmail.com');
          $message->to($data1['useremail']);
          $message->subject($data1['subject']);
        });
        //kreiranje novog usera tj. upis reda u 'users' tabelu
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => bcrypt($data['password']),
            'telefon' => $data['telefon'], //ja dodo posto se pri registraciji upisuje i telefon
            'grad' => $data['grad'], //ja dodo posto se pri registraciji upisuje i grad
            'verification' => $verification_code //ja dodo posto se pri registraciji upisuje i verifikacioni kod
        ]); 
}
Vju registracija.blade.php koji je zapravo email iz 'auto\resources\views\email' pogledaj zakomentarisan je
Pravim rutu za aktivacija( ) metod UsersControllera
Route::get('aktivacija/{verication}', 'UsersController@aktivacija');
Komandom "php artisan make:controller UsersController" pravim UsersController koji ce imati metod aktivacija( ) 
//metod poziva ruta 'aktivacija/{verication}' kada user koji se registrovao primi aktivacioni email link u njemu ide na ovaj metod koji kolonu
//aktivan 'users' tabele menja u 1
public function aktivacija(Request $request, $verification_code){
  //nalazimo usera po koloni 'verification' a to je stiglo kroz link kao argument	
  $user = User::where('verification', $verification_code)->first();
  $user->aktivan = 1;// menjamo kolonu aktivan u 1
  $user->save(); // cuvamo promenu
  $successactivation = 'Uspesno ste aktivirali vas nalog.';//pravimo succes message
  Session::flash('successactivation', $successactivation);
  return view('/users/profile')->withUser($user);//saljemo usera na vju profile.blade.php iz 'auto\resources\views\users'
}

PROFIL KORISNIKA
U UsersControlleru pravim metod profil( ) koji usre koji su aktivni salje na vju profile.blade.php gde mogu dopuniti svoj profil dodatnim podatcima
U profil.blade.php iz 'auto\resources\views\users' dodajem da na vrhu u div-u .row jobs podatcikorisnika u kom je tabela(deo template-a koji sam skinuo sa neta) prikazuje osn-
-ovne podatke korisnika koje je uneo prilikom registracije(ime, grad, telefon, email i br oglasa) 
Forma za dopunu tj izmenu podataka usera u profil.blade.php vidljiva je kad se klikne h1 .naslovdodajpodatkekorisnika onda hendler u profil.js iz 'auto\public\js\autojq' u kom su
-svi hendleri za ovaj vju, uklanja hidden atribut sa diva u kom je forma i ona postaje vidljiva korisniku.
U formi su vec popunjena polja ime, grad i telefon posto ih je user uneo prilikom registracije i ona moraju biti popunjena i kada se sabmituje ova forma za dopunu tj izmenu poda-
-taka. Postoje jos polja 'prikazi email' gde user ako kaze da u selectu odlucuje da ce mu u oglasima biti vidljiv email, 'pravno lice' gde ako kaze da u selectu znaci da je firma, 
-'adresa' gde koisnik moze uneti adresu ili neku blizu lokaciju posto je prilikom registracije naveo samo grad, zatim polja 'telefon2' i 'telefon3' gde moze navesti dodatne telefone,
-onda polje logo tj upload logo-a ako je korisnik firma pa hoce da mu bude vidljiv logo i na kraju moze dodati google map - prikazana je pomocu google mapa mapa srbije i onda
-korisnik moze zumirati i kliknuti na mapu i time popunjava inpute lat, lng i zoom koji su ispod mape(ti inputi imaju atribut readonly tako da ih user ne moze rucno popuniti) 
 na vrhu app.blade.php layouta sam dodao sta treba tj link za prikaz mape-moguce je prikazati mapu na 2 nacina sa API key i bez njega za sada koristim ovo sa APikey  
U profil.js je u hendleru za klik na h1 .naslovdodajpodatkekorisnika takodje i prikaz google map-a, pogledaj zakomentarisano je.
Posto pored svakog polja u formi postoji mala i(info) ikonica koja na klik prikazuje help korisniku u profil.js sam napravio hendlere za te klikove koji ispod polja u formi prikazuju -
-helpove korisniku, pogledaj zakomentarisano je u profil.js
Posto sad user moze da dopuni podatke koje je uneo prilikom registracije tj 'users' tabelu treba napraviti kolone u 'users' tabeli gde ce ovi podatci biti upisani, pravim migraciju-
-za dodavanje potrebnih kolona komandom "php artisan make:migration add_kolone_za_podatke_to_users_table --table=users" u migraciju upisujem ovo-
public function up(){
        Schema::table('users', function (Blueprint $table) {
            $table->integer('prikaziemail')->default(0);
            $table->integer('pravnolice')->default(0);
            $table->string('adresa')->nullable();
            $table->string('telefon2', 20)->nullable();
            $table->string('telefon3', 20)->nullable();
            $table->integer('logo')->default(0);
            $table->double('lat')->nullable();
            $table->double('lng')->nullable();
            $table->integer('zoom')->nullable();
        });
}
Takodje u down( ) metodu se dropuju ove kolone(pogledaj ako te zanima...)
U UsersControlleru pravim metod editusera( ) koji se poziva kad se sabmituje forma za dopunu ili izmenu podataka usera. Metod je poveliki pa ga necu ovde kopirati ali je zako-
-mentarisan dosta pa ga pogledaj. Metod takodje osim sto dopunjava 'users' tabelu, ako user doda logo tj sliku pravi folder u 'auto\public\img\users\' koji se zove kao userov id i
-u njega ubacuje resize-ovanu sliku tj logo usera, ako je user vec imao logo onda ne pravi novi  folder vec samo brise sve iz foldera koji se zove kao userov id i onda u njega uba
-cuje novu sliku
Sada dodajem pored uploadovanog logoa u formi u profil.blade.php btn Obrisi Sliku koji je u formi vidljiv samo ako je user vec uploadovao logo. Pravim za njega hendler u 
-profil.js koji ce slati AJAX metodu obrisilogo( ) UsersControllera koji ce brisati logo usera(ovo je potrebno jer user je mogao da obrise stari logo tako sto uploaduje novi ali neko 
-hoce da totlano obrise logo)
pravim rutu ka obrisilogo( ) metodu
//kad se u formi za dodavanje ili izmenu podataka korisnika u profil.blade.php (ako user ima dodat logo) klikne btn Obrisi Logo, hendler u profil.js
//salje ajax obrisilogo() metodu UsersControllera koristeci ovu rutu
Route::post('/obrisilogo', [
  'uses' => 'UsersController@obrisilogo',
  'as' => 'obrisilogo'
]);
pravim u profil.js hendler za klik na btn .obrisilogo, zakomentarisano je pa necu ovde kopirati, znaci hendler salje id usera metodu obrisilogo( ) UsersControllera preko rute /obrisi-
-logo.
Metod obrisilogo( ) UsersCOntrollera u celosti (posto nije veliki...)
//metod se koristi ako user ima dodat logo ali zeli da ga obrise, ako ima logo u formi u profil.blade.php pored slike logo-a ima btn ObrisiLogo
//(.obrisilogo) koji kad se klikne poziva hendler iz profil.js koji salje AJAX u ovaj metod i u njemu id usera kom treba obrisati logo 
public function obrisilogo(Request $request){
  //nalazimo usera u 'users' tabeli po id-u koji je stigao AJAX-om
  $user = User::find($request['userid']);
  $user->logo = 0;//menjamo logo kolonu 'users' tabele u 0
  $user->save();//cuvamo promenu u bazi
  //putanja ka folderu u 'auto\public\img\users' u kom je bio logo usera koji brise logo
  $path = public_path('/img/users/').$user->id;
  File::cleanDirectory($path);//brisemo sliku iz foldera
  return response()->json(1);//vracamo hendleru u profil.js 1
}
Isto ovo pravim za google map tj ako je user dodao google map onda iznad google mape u formi u profil.blade.php ima btn Obrisi Mapu, koji kad se klikne brise kolone lat,lng i -
-zoom iz 'users' tabele tj to radi obrisimapu( ) metod UsersControllera a hendler za klik na btn .obrisimapu mu salje AJAX preko rute -
Route::post('/obrisimapu', [
  'uses' => 'UsersController@obrisimapu',
  'as' => 'obrisimapu'
]);
ovo je metod obrisimapu( ) UsersControllera 
//metod se koristi ako user ima dodatu mapu ali zeli da je obrise, ako ima mapu u formi u profil.blade.php iznad mape ima btn Obrisi Mapu
//(.obrisimapu) koji kad se klikne poziva hendler iz profil.js koji salje AJAX u ovaj metod i u njemu id usera kom treba obrisati mapu 
public function obrisimapu(Request $request){
  //nalazimo usera u 'users' tabeli po id-u koji je stigao AJAX-om
  $user = User::find($request['userid']);
  $user->lat = null;//menjamo lat, lng i zoom kolone na null
  $user->lng = null;
  $user->zoom = null;
  $user->save();//cuvamo promenu u bazi
  return response()->json(1);//vracamo hendleru u profil.js 1
}
Kad hendler za klik na Obrisi Mapu btn dobije odgovor od kontrolera uklanja btn Obrisi Mapu, menja tekst iznad mape iz 'Izmeni Mapu' u 'Dodaj Mapu', prazni polja lat,lng i zoom
-i ponovo poziva initialize( ) funkciju (koja je napravljena u profil.js) da opet nacrta mapu sa koordinatama i zoom-om koji prikazuje celui Srbiju(pogledaj zakomentarisano je)

Napravio vju users.blade.php u 'auto\resources\views\admin' koji ce sluziti da admin radi sa nalozima korisnika. Za sada vju samo prikazuje korisnike koje mu vrati metod -
-korisnici( ) UsersControllera koji vadi po 5 usera koji su aktivni(to sve treba doraditi tako da admin vidi i neaktivne korisnike i da moze da ih pretrazuje itd...) Takodje sam prepra-
-vio i metod profil( ) UsersControllera koji je do sada vadio samo ulogovanog usera a pozivao ga je user koji je autor kad klikne u navigacijji link 'Profil' a sada i admin kad gleda-
-u users.blade.php korisnike pored svakog ima btn 'Idi Na Profil' koji kad klikne poziva ovaj metod ali i salje kao parametar id usera pa onda metod ako je stigao id usera vadi po-
-tom id-u usera a ako nije onda vadi trenutno ulogovanog(pogledaj metod zakomentarisan je) takodje sam promenio i rutu '/profil' pa sada ima opcioni parametar id
Sve ovo jos treba doraditi tako da u users.blade.php admin moze da pretrazuje usere po name i id kolonama a mozda i po email

SELO

VAZNO VAZNO VAZNO
U VJUU profile.blade.php JE BIO BUG TJ KAD JE USER KOJI ULAZI NA VJU ADMIN IZ NEKOG RAZLOGA JE JS FAJL profil.js IMAO PROBLEM DA PRIKA
ZE SLIKE TJ PRAVIO JE LOS SRC PA SAM ONDA NA DNU VJUA DODAO VARIIABLU var slikeurl = '{{ url('/') }}' I KORISTIM JE U profil.js KAD PR
AVIM src ATRBUT ZA IKONICE ZA ZATVARANJE HELP DIV-OVA KAO NPR. OVDE
infomapa += '<img src="'+slikeurl+'/img/redclose.png" class="pull-right zatvoriinfo" id="zatvorimapinfo">';
NE ZNAM U CEMU JE PROBLEM, TO SE NE DESAVA KAD NA VJU ULAZI USER KOJI NIJE ADMIN, MOZDA JE NESTO ZBOG OPCIONOG PARMETRA ID U URL-U

users.blade.php 
kad se klikne link Korisnici u adminovoj navigaciji preko rute '/korisnici' poziva metod korisnici() UsersControllera koji u tom slucaju vadi
4 usera kojima je rola author i salje ih u vju users.blade.php. Svaki korisnik se prikazuje u tabeli koja je ista ona tabela koja prikazuje osnovne podatke 
korisnika u profil.blade.php samo sto sada admin pored svakog korisnika ima btn Profil koji ga kad klikne salje na metod profil() UsersControllera koji mu
prikazuje profil korisnika koji admin moze menjati a ako je korsnk neaktivan onda ima i btn Aktiviraj kojim moze aktivirati korisnika tj promeniti kolonu active 'users'
tabele iz 0 u 1
(OVO TEK TREBA NAPRAVITI)
Iznad prikazanih korisnika postoje i polja za pretragu po imenu i ID-u korisnika i takodje select kojim se kad se promeni opcija mogu sortirati korisnici po zeljenom redosledu
I pretrage korisnika po imenu i ID-u i sortiranje koriste metod korisnici() UsersCOntrollera samo mu salju drugacije parametre. Kada se pretrazuju korisnici po imenu onda hendler za klik
 na span .pretrazispanime uzima adminov unos u polje .imekorisnika dodaje to kao parametar imekorisnika na URL
-/korisnici i radi windows.location() a korisnici() metod UsersControllera kad u requestu postoji taj parametar kad radi query u 'users' tabeli dodaje WHERE name LIKE %imekorisnika% 
Isto je i za IDkorisnika samo se tad koristi hendler za klik na span .pretrazispanid parametar koji se salje kontroleru se zove idkorisnika
ovi kao i hendler za promenu opcije selecta za sortiranje rezultata su u users.js
Taj hendler uzima iz atributa kliknutog optiona selecta ime kolone po kojoj se sortira 'users' tabela i da li je ASC ili DESC i takodje kaci te parametre na URL
-/korisnici i radi windows.location() kom kao parametar daje izgenerisani URL
Posto su i metod korisnici() UsersControllera i vju users.blade.php veliki necu ih ovde kopirati ali su zakomentarisani pa pogledaj, i hendleri u users.js
su zakomentarsani
Treba napomenuti da se paginacija radi malo drugacije nego sto sam do sada radio tj dodajem Laravel-ovoj paginaciji argumente koji su potrebni da bi se napravio link
ako je radjena pretraga ili sortiranje onda se u link za paginaciju moraju dodati i parametri sort, ascdesc i imekorisnika a to se radi tako sto se poziva metod 
appends() blade paginacije i u njemu se u array-u navode varijable koje ce on okaciti kao parametre paginacionog linka 
{{-- PAGINACIJA--}}
{{-- ako je radjena pretraga po imenu tj puna je varijabla $imekorisnika jer ju je onda vratio metod korisnici() UsersControllera pagi-
   -naciji treba dodati argument 'imekorisnika' --}}
@if(!empty($imekorisnika))
  <ul class="pager">
    {!! $users->appends(['sort' => $sort, 'ascdesc' => $ascdesc, 'imekorisnika' => $imekorisnika])->links() !!} 
  </ul>
{{-- ako nije $imekorsnika vraceno iz kontrolera onda samo kao argumenti paginacije variable za sortiranje --}}
@else
  <ul class="pager">
    {!! $users->appends(['sort' => $sort, 'ascdesc' => $ascdesc])->links() !!} 
  </ul>
@endif
Takodje je vazno da kad UsersController tj metod korisnici() vrati nadjene users vrati i varijable $sort, $ascdesc koje su za sortiranje i ako je radjena pretraga
po imenu takodje vraca i varijablu $imekorisnika
Postoji i pretraga po id-u korisnika ali ona uvek vraca samo jednog korisnika. Hendler za klik na span .pretrazispanid je takodje u users.js i on takodje
radi windows.locaion() a URL koji se daje kao argument je /korisnici sa dodatim parametrom idkorisnika pa onda kad to stigne u korisnici() metod UsersControllera
ovaj zna da ako postoji taj parametar u requestu vadi korisnike po tom id-u, tj vadi jednog korisnika kom je id jednak onom id-u koji je stigao 

Manuelna aktivacija usera, tj kad admin klikne na link Aktiviraj pored nekog neaktivnog korisnika u users.blade.php, pravim rutu koja ce gadjati metod manuelanaaktivacija()
 UsereControllera koji cu napraviti
//ruta se koristi kad admin u users.blade.php aktivira korisnika klikom na link Aktiviraj, iz users.js se preko rute salje AJAX u metod
//-manuelnaaktivacija() UsersControllera 
Route::post('/manuelnaaktivacija', 'UsersController@manuelnaaktivacija');
Pravim hendler u users.js za klik na link Aktivacija tj .aktivirajbtn iz users.blade.php, mozes ga pogledati u users.js, salje AJAX metodu manuelnaaktivacija()
UsersControllera preko rute koju sam napravio i kad dobije odgovor ako je user uspesno aktiviran uklanja btn za aktivaciju pored aktiviranog usera a ako 
aktivacija nije uspela izbacuje alert sa error porukom, kad ukloni btn za aktivaciju umesto njega generse btn za Deaktivaciju istog tog usera u ubacuje ga iza 
<br class="ubaciaktivirajdeaktivirajlink{{ $user->id }}"> tj. ispod linka ka Profilu usera tako da je sada moguce deaktivirati usera
U UsersControlleru pravim metod manuelnaaktivacija() koji menja aktivan kolunu 'users' tabele onom useru ciji id stigne AJAX-om
//Metod se koristi da admin klikom na link Aktiviraj u users.blade.php aktivira nekog usera, stize AJAX iz users.js preko rute
// '/manuelnaaktivacija' i u njemu userid usera kog aktiviramo
public function manuelnaaktivacija(Request $request){
  if($request->user()->is_admin()){//koristeci is_admin() metod User.php modela proveravamo da li je user admin
    $userid = $request['userid'];//nalazimo usera kog zelimo da aktiviramo pomocu userid-a koji je stigao AJAX-om
    $user =  User::where('id', $userid)->first();
    $user->aktivan = 1;//menjamo kolonu aktivan iz 0 u 1
    $user->save();//cuvamo
    //vracamo AJAX-u json u kom je objekat sa svim podatcima aktiviranog usera
    return response()->json(['user' => $user]);
  }else{//ako nije admin saljemo ga na '/'
    return redirect('/');
  }
}
Manuelna deaktivacija usera je ista kao i aktivacja samo sto se kolona aktivan 'users' tabele menja u 0. Znaci svaki user prikazan u users.blade.php ukoliko je aktivan ima 
pored njega link Deaktiviraj koji kad se klikne poziva hendler iz users.js koji preko rute '/manuelnadeaktivacija' poziva metod manuelnadeaktivacija UsersControllera
//ruta se koristi kad admin u users.blade.php deaktivira korisnika klikom na link Deaktiviraj, iz users.js se preko rute salje AJAX u metod
//-manuelnadeaktivacija() UsersControllera 
Route::post('/manuelnadeaktivacija', 'UsersController@manuelnadeaktivacija'); 
Metod manuelnadeaktivacija() UsersControllera je isti kao i manuelnaaktivacija() samo sto koloni aktivan 'users' tabele daje vrednost 0 umesto 1
Kad hendler primi odgovor od kontrolelra uklanja link za Deaktivaciju i onda generise link za Aktivaciju usera koji se ubacuje ispod linka ka profilu usera tj
iza <br class="ubaciaktivirajdeaktivirajlink{{ $user->id }}">
Takodje sam u stjles.css ubacio malo css za crveni link tj btn za Deaktivaciju usera
I metod manuelnadeaktivacija UsersControllera i hendler u users.js su zakomentarisani pa ih necu ovde kopirati

DODAVANJE OGLASA
Pravim OglasController komandom "  php artisan make:controller OglasController " koji cu koristiti za dodavanje novih oglasa. U njemu na vrhu u __construct( ) metodu kazem 
da je u Auth middleware-u.
Pravim vju novioglas.blade.php u 'auto\resources\views\users' u kom cu napraviti formu za dodavanje oglasa
Pravim rutu '/novioglas/{id?}, ruta ima opcioni parametar id da bi ako stigne id u requestu metod izvukao usera po tom id-u(to se koristi kad admin za nekog usera pravi oglas)
Route::get('/novioglas/{id?}', 'OglasController@novioglas')->name('novioglas');
Pravim metod novioglas( ) u OglasControlleru koji proverava da li je requester admin ili obican aktivan user i onda ako je admin vadi iz 'users' tabele usera po id-u koji je stigao u
requestu a ako je aktivan user requester(tj nije admin) user je $request->user(); i onda pozivam vju novioglas.blade.php i saljem mu usera
//metod vraca vju novioglas.blade.php iz 'auto\resources\views\users' u kom je forma za dodavanje novog oglasa, ako je u requestu stigao id zna-
//ci da ga poziva admin koji ce za nekog usera postaviti oglas, ako nije znaci da ga poziva user koji je aktivan
public function novioglas(Request $request, $id = null){
  //ako je requester admin i ako je stigao id	
  if($request->user()->is_admin() && $id != null){ 
    $user = User::where('id', $id)->first();//iz 'users' tabele vadimo usera po id koji je stigao u requestu
    return view('users.novioglas')->withUser($user);//pozivamo vju novioglas.blade.php i saljemo mu usera
  //ako je requester aktivan tj nije admin	
  }elseif($request->user()->aktivan()){
    $user = $request->user(); // $user ce biti requester
    return view('users.novioglas')->withUser($user);//pozivamo vju novioglas.blade.php i saljemo mu usera
  }else{//u suprotnom saljemo requestera na '/'
    return redirect('/');
  }
}

Poceo rad na vjuu novioglas.blade.php u kom je forma za dodavanje novog oglasa i na fajlu novioglas.js u kom su hendleri za taj vju takodje sam napravio rutu koja sluzi da 
-pozove metod izvadimodele() OglasControllera koji vadi sve modele neke marke kad user u formi za novi oglas u selectu odabere marku onda ide AJAX iz hendlera u 
-novioglas.js koji preko ove rute i metoda vadi modele te marke i lepi ih na select za biranje modela

//ruta se koristi kad u novioglas.blade.php u selectu za odabir marke automobila odaberemo marku, onda preko ove rute ide iz novioglas.js
//AJAX ka metodu izvadimodele() OglasControllera koji vadi sve modele marke koju smo odabrali
Route::post('/izvadimodele', 'OglasController@izvadimodele')->name('izvadimodele');

Takodje sam napravio funkcionalnost da ako user medju ponudjenim modelima ne nadje onaj koji zeli klikne u selectu za model opciju Ostalo... i onda se select pretvara u text 
-input u koji user sam moze ukucati ime svog modela automobila
Za select za godiste automobila koristio sam laravelcollective paket koji sam instalirao komanom " composer require "laravelcollective/html":"^5.2.0" " i onda sam u 
-config/app.php dodao sta treba u providers i aliasses array-e, pogledaj u formi kako je napravljeno polje, znaci opseg godina je od 1930 d0 2017 
Prvo sam u novioglas.js validaciju radio na focusout za svako polje i tako dalje pa onda kad se hoveruje submit btn on proveri da li su kontrolne varijable za svako polje 0 ili 1 a 
-sada sam napravio novi novoglas.js i sada kad se radi hover na submit btn-u sve tada radi tako da nema hendlera za svako polje u formi zasebno vec sve radi hendler za 
-submit btn
Takodje poceo rad na tome da kad se popnjavaju polja snagaKW ili snagaKS u ovo drugo sam upisuje vrednost koju sam izracunava tako da  user moze da upise samo recimo
- KS a Kw ce se sami popuniti i obrnuto
Cela forma ima sekcije, prvo su osnovni podatci o vozilu (marka, model, kubikaza, konjaza, godiste itd) ta polja su obavezna za popunjavanje i validacija za to  je u novioglas.js u 
-hendleru za hover na submit btn, zatim je sekcija Sigurnost u kojoj su checkbox-ovi i oni nisu obavezni za popunjavanje, zatim sekcija Oprema isto checkbox-ovi in nije 
-obavezno, zatim sekcija Stanje vozila ista prica, checkbox-ovi  nije obavezno, i onda ide <textarea> u koju user moze da ukuca kraci tekst tipa opis vozila, uslovi kupovine, 
-detalji o lokaciji i tako dalje
Pri dnu forme ispod svih checkbox-ova kojima user popunjava kolone 'dodatnaoprema', 'sigurnost' i 'poreklo'(koje treba napraviti) ima sekcija za dodavanje slika
Tu je moguce dodati 12 slika, ne vide se inputi za upload fajla posto su skriveni a umesto njih se vidi njihov <label> koji je slika siluete automobila tako da kad je user klikne iskace
- mu dialog-box za upload slike, kad odabere sliku umesto te koja je po difoltu pojavljuje se ona koju je dodao, hendleri za svaku sliku posebno su u novioglas.js a svaki od njih
- poziva funkciju readURL() koja to obavlja(takodje je u novioglas.js), ovako izgleda jedno polje za upload slike u formi za novi oglas
<div class="col-md-2">
  <div class="image-upload">
    <label for="slika1" class="slikaupload">
      <img style="width: 150px; height: 80px;" id="slika1holder" src="{{ asset('img/kolasilueta2.png') }}"/>
    </label>
    <input id="slika1" type="file"/>
  </div>
</div> 

Tabela za oglase
Komandom " php artisan make:model Oglasi --migration " pravim model Oglasi.php i migraciju za 'oglasis' tabelu, za sada sam u migraciju dodao ove kolone
$table->increments('id');
            $table->integer('user_id')->unsigned();
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->string('naslov');
            $table->string('marka');
            $table->string('model');
            $table->integer('cena');
            $table->integer('godiste');
            $table->string('karoserija');
            $table->integer('kubikaza');
            $table->integer('snagaks');
            $table->integer('snagakw');
            $table->integer('kilometraza');
            $table->string('gorivo');
            $table->string('emisionaklasa');
            $table->string('pogon');
            $table->string('menjac');
            $table->integer('ostecen');
            $table->integer('brvrata');
            $table->integer('brsedista');
            $table->string('strvolana');
            $table->string('klima');
            $table->string('boja');
            $table->string('poreklo');
            $table->string('sigurnost')->nullable();
            $table->string('oprema', 450)->nullable();
            $table->string('stanje')->nullable();
            $table->text('tekst')->nullable();
            $table->string('folderslike')->nullable();
            $table->integer('slike');
            $table->integer('brpregleda');
            $table->integer('odobren')->default(0);	
            $table->timestamps();
            $table->index(['marka', 'model', 'kubikaza']);
migriram komandom " php artisan migrate " 
U modelu Oglasi.php pravim fillable array
protected $fillable = ['user_id', 'naslov', 'marka', 'model', 'cena', 'godiste', 'karoserija', 'kubikaza', 'snagaks', 'snagakw', 'kilometraza', 'gorivo', 'emisionaklasa', 'pogon', 'menjac', 
                                   'ostecen', 'brvrata', 'brsedista', 'strvolana', 'klima', 'boja', 'poreklo', 'sigurnost', 'oprema', 'stanje', 'tekst', 'slike', 'brpregleda', 'odobren']; 
Povezujem modele Oglasi.php i User.php one-to-many relacijom tj user ima vise oglasa, u Oglasi.php pravim metod user( ) 
//one to many relacija sa User.php modelom tj tabelom 'users'
public function user(){
    return $this->belongsTo('App\User', 'user_id');	
}
a u User.php metod oglasis( ) 
//one to many relacija sa Oglasi.php modelom tj tabelom 'oglasis'
public function oglasis(){
      return $this->hasMany('App\Oglasi', 'user_id');
}
Pravim rutu '/upisinovioglas' koja gadja istoimeni metod OglasControllera
//ruta se koristi kad se u novioglas.blade.php sabmituje forma za novi oglas, gadja metod upisinovioglas() OglasControllera
Route::post('/upisinovioglas', 'OglasController@upisinovioglas')->name('upisinovioglas');
Pre svega posto ce se dodavati slike za oglase u folderu 'auto\public\img' pravim folder 'oglasi' ,  u njemu ce svaki user imati folder koji ce se zvati kao i njegov verifikacioni kod,
-taj folder ce praviti metod create( ) AuthControllera koji prima submit forme  za registraciju novog usera, hteo sam da se napravi folder koji se zove kao id usera ali posto ovaj me
-tod vraca id u vju tj id ne postoji u kontrolleru posto cim napravi usera radi return moram da koristim verifikacioni kod kao ime foldera u koji user ubacuje slike za oglase, znaci sv
-aki user ima svoj folder pa onda kad se napravi oglas u njemu se pravi novi folde u kom su slike za taj oglas, takodje sam rollbackovao migraciju za 'oglasis' tabelu i dodao joj ko
-lonu folderslike u koju cu upisivati taj string tj verifikacioni kod usera koji postavlja oglas tj ime foldera u koji idu slike za tog usera
VAZN VAZNO VAZNO da bi taj string(verifikacioni kod) bio 100% jedinstven treba napraviti da ga pravi od npr imena usera i trenutnog vremena u milisekundu
Ovo sam dodao u create( ) AuthControllera
//proba kreiranja foldera za slike koje ce ovaj user dodavati kad postavlja oglase
$path = public_path().'/img/oglasi/' . $verification_code;
File::makeDirectory($path, $mode = 0777, true, true);
VAZNO VAZNO VAZNO
kad sam uploadovao velike slike pucalo je i javljalo da je $_POST prevelik pa sam na youtubu (https://www.youtube.com/watch?v=apUiiH42TUw) nasao ovaj klip, pa sam u 
-php.ini fajlu prvo povecao post_max_size sa 8M  na 8000M a onda se poveca upload_max_filesize sa 2M na 2000M i sada dodaje i velike slike, takodje posto se za svaku dod
-atu sliku pravi thumbnail pucalo je posto nije bilo dovoljno veliki memory_limit (memory_limit=128M) tako da sam ga povecao na 2000M i sada bez problema resizuje slike

Metod upisinovioglas( ) OglasControllera prvo proverava da li je user koji ga je pozvao admin ili aktivni autor (posto admin moze uneti za nekog usera oglas, forma za unos nov-
-og oglasa u novioglas.blade.php ima hidden polje user_id i ta vrednost se upisuje u kolonu user_id u 'oglasis' tabeli) i zatim proverava tj radi validaciju obaveznih polja u formi -
-za dodavanje novog oglasa u novioglas.blade.php jos jednom iako u novioglas.js ima javascript validacija, zatim popunjava kolone u 'oglasis' tabeli onim sta je user uneo u -
-formu, kolone sigurniost, oprema i stanje se popunjavaju tako sto metod upisinovioglas( ) poziva private metode sigurnost( ), oprema( ) i stanje( ) kojima se salje $request a oni-
-proveravaju sta je u istoimenim sekcijama u novioglas.blade.php cekirano i od toga prave string koji se upisuje u istoimene kolone 'oglasis' tabele, ovako sam napravio posto cu
-iste private metode koristiti i za editovanje postojeceg oglasa tj submit forme u izmenioglas.blade.php
Zatim kad upise novi oglas u oglasis tabelu u userovom folderu za slike(koji se zove kao userov verifikacioni kod, a nalazi se u folderu "public/img/oglasi") pravi folder koji se zove
- kao id upravo upisanog oglasa i onda proverava da li je i koje slike po redu uploadovao user u formi i upisuje ih u taj folder, zatim broj slika upisuje u kolonu slike 'oglasis' tabele 
-tj updateuje je
Takodje, ako ima slika, pravi i thumb.jpg od slike 1.jpg i smanjuje ga na 180x120 px da bi kad prikazuje vise oglasa na stranici vadio thumbove koji su malih dimenzija
Na kraju radi redirect na rutu 'profil' kojoj sam dodao jos 2 opciona parametra slike i novioglasid, pa sam malo menjao taj metod da ako stignu ta 2 parametra, to znaci da je re-
-quest stigao iz upisinovioglas( ) OglasControllera i onda on vadi taj novi oglas ciji je id stigao iz 'oglasis' tabele i salje u vju profil.blasde.php a takodje i broj slika da bi vju mogao-
-da prikaze na vrhu upravo uneti oglas
vju profil.blade.php sam malo menjao tj on ce sada kad vidi varijable $novioglas i novioglasmessage u sesiji na vrhu prikazati upravo dodati oglas 
Takodje vadimo sve oglase koje je do sada ovaj user dodao posto profil.blade.php prikazuje i njih (ovo je moglo i u vjuu da se uradi koristeci $user->oglasis ali je orderovao od 
-najstarijih ka novijim a ja sam hteo obrnuto)

U profil.blade.php pravim sekciju za prikiaz do sada unetih oglasa usera na cijem smo profilu, vju prvo proverava kolonu brojoglasa 'users' tabele i ako je veca od 0 on prikazuje-
-h1 .naslovoglasikorisnika koji se ponasa kao btn i koji kad se klikne divu .oglasikorisnikaprofil skida hidden="true" (to se radi u profil.js) i pojavljuje se div u kom su prikazani ogl-
-asi korisnika od najnovijeg ka starijim, prikazuje se slika, naslov, cena i jos neki osnovni podatci(pogledaj vju...) Takodje postoje btn-i "Izmeni Oglas" i "Obrisi Oglas" koje vide i -
-user i admin i postoje btn-i "Odobri Oglas" ako je oglas neodobren ili "Zabrani Oglas" ako je oglas odobren koje vidi samo admin
Posto sam ovo dodao morao sam i u UsersControlleru u metodu profil( ) da dodam da vadi sve oglase usera ciji vju ce biti prikazan i salje ih u vju profi.blade.php 
$oglasi = Oglasi::where('user_id', $userId)->orderBy('created_at', 'desc')->get();

Odobravanje oglasa tj adminov klik na btn Odobri Oglas pored neodobrenog oglasa u profil.blade.php
<button type="button" id="odobrioglasbtn{{ $oglas->id }}" class="btn btn-success btn-block odobrioglas" oglasid="{{ $oglas->id }}">
    Odobri&nbsp; Oglas
</button>
Prvo pravim rutu Route::post('/odobrioglas', 'OglasController@odobrioglas')->name('odobrioglas'); koja ce gadjati metod odobrioglas( ) u OglasControlleru i na dnu vjua profil.-
-blade.php u <script> ubacujem tu rutu - var urlodobrioglas = '{{ route('odobrioglas') }}'; posto ce se slati AJAX iz profil.js pa da bi imao pristup ruti
Zatim pravim hendler u profil.js koji salje AJAX u odobrioglas( ) OglasControllera i u njemu id oglasa koji se odobrava i _token i zatim ovaj vraca odgovor u kom je taj oglas i onda-
-.done( ) proverava da li je kolona odobren prmenjena u 1 i ako jeste brise btn Odobri Oglas i umesto njega generise btn Zabrani Oglas takodje uklanja <span> u kom pise da je
-oglas neodobren (taj <span> je pored datuma postavljanja oglasa) i umesto njega pravi <span> u kom pise Odobren
Isto to pravim za Zabranu oglasa tj klik na btn Zabrani Oglas koji admin vidi u profil.blade.php pored oglasa korisnika koji su odobreni
<button type="button" id="zabranioglasbtn{{ $oglas->id }}" class="btn btn-warning btn-block zabranioglas" oglasid="{{ $oglas->id }}">
    Zabrani Oglas
</button>
ruta
//ruta ide na metod zabranioglas() OglasControllera koji zabranjuje oglas tj menja oglasu kolonu odobren iz 1 u 0, ide AJAX iz profil.js
Route::post('/zabranioglas', 'OglasController@zabranioglas')->name('zabranioglas');
pravim hendler za klik na ovaj btn u profil.js koji metodu zabranioglas( ) OglasControllera salje AJAX i u njemu id oglasa i _token i onda sve isto kao za odobravanje samo sto pos
-le .done( ) uklanja Zabrani Oglas btn i stavlja Odobri Oglas i isto sa <span> - om pored datuma postavljanja, menja ga iz odobren u neodobren  

Brisanje Oglasa tj klik na btn Obrisi Oglas u profil.blade.php pored nekog oglasa nekog usera
<button type="button" class="btn btn-danger btn-block obrisioglas oglasbtnprofilblade" idoglasa="{{ $oglas->id }}" id="obrisioglasbtn{{ $oglas->id }}">
   Obrii&nbsp;&nbsp;&nbsp; Oglas
</button>
pravim rutu koja ide na metod obrisioglas( ) OglasControllera
//kad se klikne btn Obrisi Oglas u profil.blade.php pored nekog oglasa nekog usera preko ove rute ide AJAX u metod obrisioglas() OglasControlera
Route::post('/obrisioglas', 'OglasController@obrisioglas')->name('obrisioglas');
U profil.js pravim hendler za klik na btn koji uzima iz atributa btn-a idoglasa id oglasa koji se brise i salje ga sa _token-om u OglasController koji brise oglas, folder u kom su slike-
-oglasa(a taj folder je u public/img/oglasi/(folder korisnika koji se zove kao verifikacioni kod korisnika)), i zatim smanjuje kolonu brojoglasa 'users' tabele za jedan kod korisnika ciji
-je oglas obrisan i vraca u profil.js delete koji je true ako je oglas obrisan, idoglasa koji je obrisan i novi broj oglasa usera i zatim .done u profil.js brise prikaz obrisanog oglasa i -
-u tabeli na vrhu profil.blade.php koja prikazuje podatke korisnika prikazuje novi broj oglasa korisnika ciji je oglas obrisan. Oglas moze obrisati Admin ili autor oglasa i to proverava
-metod obrisioglas( ) OglasControllera 

Brisanje Usera tj klik na btn Obrisi Profil koji je u tabeli koja prikazuje podatke usera u profil.blade.php 
<td class="tbl-apply">
  {{-- link za brisanje profila, gadja metod obrisikorisnika() UsersControllera --}}
  <a class="orangebtn" href="{{ url('obrisikorisnika/'.$user->id.'?_token='.csrf_token()) }}" onclick="return confirm('Da li ste sigurni da zelite da obrisete profil?');" id="obrisiprofilbtn">
    Obrii Profil
  </a>
</td>
Pravim rutu '/obrisikorisnika/id'
//ruta se koristi kad se u profil.blade.php klikne link za brisanje profila, koji je vidljiv adminu i vlasniku profila, ide na metod -
// - obrisikorisnika() UsersControllera koji brise korisnika, njegove oglase i logo korisnika i slike oglasa
Route::get('obrisikorisnika/{id?}', 'UsersController@obrisikorisnika')->name('obrisikorisnika');
Zatim u UsersControlleru pravim metod obrisikorisnika( ) koji dobija kroz GET id korisnika koji se brise, zatim ga nalazi u 'users' tabeli, proverava da li je requester admin ili vlasnik
-profila koji se brise, ako nije vraca ga na '/', zatim brise korisnika i onda brise logo ako ga ima i takodje brise korisnikov folder za dodavanje slika oglasa koji se zove kao i korisni-
-kov verifikacioni kod i onda ako je admin vraca ga na rutu '/korisnici' a ako je profil obrisao vlasnik profila vraca ga na '/'
Oglasi se brisu automatski posto u migraciji za 'oglasis' tabelu users_id kolona je foreign key na id kolonu 'users' tabele i onda on delete cascade
$table->integer('user_id')->unsigned();
$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
Zakomentarisano je pa pogledaj...

IZMENE TJ UPDATE OGLASA
Klik na btn Izmeni Oglas u profil.blade.php pored nekog od prikazanih oglasa nekog korisnika preko rute 'izmenioglasforma/{id}' gadja metod izmenioglasforma( ) OglasCont-
-rollera
btn tj link Izmeni Oglas
<a id="aktiviraj" class="bezdekoracije" userid="{{ $user->id }}" href="{{ url('izmenioglasforma/'.$oglas->id.'/'.$user->id) }}">
   <button type="button" class="btn btn-primary btn-block oglasbtnprofilblade">
     Izmeni&nbsp;&nbsp; Oglas
   </button>
</a>
ruta
Route::get('izmenioglasforma/{id}/{userid}', 'OglasController@izmenioglasforma')->name('izmenioglasforma');
U folderu 'auto\resources\views\users' pravim vju izmenioglas.blade.php u kom ce biti forma za menjanje oglasa, u folderu 'auto\public\js\autojq' pravim izmenioglas.js u kom ce -
- biti jquery za vju
U OglasControlleru pravim metod izmenioglasforma( ) koji dobija id oglasa koji se menja i id usera ciji je oglas i onda ih vadi iz baze i salje u vju izmenioglas.blade.php, pre toga -
- proverava da li postoje id i user sa tim id-evima, da li je requester admin ili autor oglasa i da li je user_id kolona oglasa == id usera koji je stigao, pogledaj metod zakomentarisan
- je
U izmenioglas.blade.php pravim formu koja je ista kao u novioglas.blade.php samo sto je cim se ucita vju popunjena podatcima iz 'oglasis' tabele, sve je manje vise isto takodje
-validacija koju pravim u izmenioglas.js je kopirana iz novioglas.js, jedino je drugaciji rad sa slikama
Ako oglas nema dodate slike odmah se na dnu forme iscrtava 12 inputa za upload slike
Ako oglas ima slike i ako ih je 12 onda ih sve iscrtavamo i svaka ima u gornjem levom uglu trash ikonu za brisanje i useru ispisujemo da ne moze da doda nove dok ne obrise ne
-ke od vec dodatih posto ima maximalan br slika, kad user klikne na trash ikonu iznad neke slike hendler iz izmenioglas.js salje AJAX metodu obrisisliku( ) OglasControllera koji -
-brise sliku i smanjuje u 'oglasis' tabeli kolonu slike za 1 i zatim kad stigne odgovor od kontrolera dodaje ispod prikaza slika oglasa jedno polje za upload slike koje se zove kao 
-upravo obrisana slika(tj ako user obrise 2.jpg polje ce se zvati name="slika2")
Ako user ima dodate slike ali ne 12 nego manje onda se proverava koliko slika moze da doda (12 - brslika), upload file inputi se crtaju tako sto se vrti for petlja 12 puta i ako ne 
-postoji fajl koji se zove $i.jpg tj ne postoji ta slika onda se za nju crta upload file input
@for($i = 1; $i <= 12; $i++)     
              @if(!file_exists("img/oglasi/$oglas->folderslike/$oglas->id/$i.jpg"))
                @php 
                  $dodatihinputazaslike++; 
                @endphp
              <div class="col-md-2">
                <div class="image-upload">
                  <label for="slika{{ $i }}" class="slikaupload">
                    <b>Slika {{ $i }}</b><br>
                    <img style="width: 150px; height: 80px;" id="slika{{ $i }}holder" src="{{ asset('img/kolasilueta2.png') }}"/>
                  </label>
                  <input id="slika{{ $i }}" name="slika{{ $i }}" type="file"/>
                </div>
              </div>
        @if($dodatihinputazaslike == 6)
          </div>
          <div class="row redzaslike2">
        @endif
            @endif
@endfor
I ovde ako se brisu slike dole se dodaje input za upravo obrisanu sliku
(malo je ovo zapetljano ovo sa slikama ali je zakomentarisano u izmenioglasd.blade.php i u izmenioglas.js pa pogledaj)
Kad se forma sabmituje onda preko rute '/izmenioglas' ide na izmenioglas( ) OglasControllera
//ruta se poziva kad se sabmituje forma za izmenu oglasa iz izmenioglas.blade.php i gadja izmenioglas() OglasControllera
Route::post('/izmenioglas', 'OglasController@izmenioglas')->name('izmenioglas');
Metod je skoro isti kao novioglas( ) OglasControllera, samo sto na pocetku nalazi oglas koji menjamo po id oglasa i onda ga update-uje, takodje poziva private metode OglasCo
-ntrollera - sigurnost( ), oprema( ), stanje( ) koji prave stringove koji se upisuju u istoimene kolone 'oglasis' tabele i onda save - ujemo oglas, za slike je isto kao i u novioglas( ) 
ide for 12 puta i ako je stigao u requestu file(slika.$i) onda tu sliku upisujemo u oglasov folder u userovom folderu i povecavamo kolonu slike 'oglasis' tabele za 1
Takodje na kraju kao u novioglas( ) pozivamo rutu 'profil' tj metod profil( ) UsersControllera i saljemo mu sta treba (id usera, br slika i id oglasa)tako da ovaj ucitavaprofil.blade.php
-i salje mu oglas ( tj novioglas i ako je ovo menjanioglas a ne novi ali da ne bih menjao... tako ce se i dalje zvati) jedino sto u session upisujemo u $novioglasmessage da nije
-user dodao novi oglas nego izmenio postojeci pa mu se ta poruka prikazuje a profil.blade.php posto je popunjena varijabla $novioglas na vrhu prikazuje izmenjeni oglas i sta je
-uneo user i slike oglasa  

ADMINOVO UPRAVLJANJE OGLASIMA TJ UREDJIVANJE ISTIH
Pravim rutu '/adminoglasi' koja gadja metod adminoglasi( ) OglasControllera koji vraca vju adminoglasi.blade.php koji pravim u 'auto\resources\views\admin' i takodje pravim fajl
-  adminoglasi.js u 'auto\public\js\autojq' u kom ce biti hendleri za vju
//ruta gadja adminoglasi() OglasControllera koji adminu vraca vju adminoglasi.blade.php sa po 10 najnovijih odobrenih i neodobrenih oglasa
Route::get('/adminoglasi', 'OglasController@adminoglasi');
Ta ruta tj linkovi ka njoj su u navigaciji koju vidi admin (link Oglasi) i u adminpanel.blade.php treca slika (lupa na kolima - Oglasi Korisnika)
Kontroler tj metod adminoglasi( ) vadi po 10 najnovijih odobrenih i neodobrenih oglasa i salje ih i u vju koji ih prikazuje, svaki od oglasa se moze obrisati, editovati i odobriti ili zab-
-raniti, takodje za svaki oglas od ovih 20 prikazane su slike i svi podatci oglasa tako da admin ima kompletan uvid, 
Takodje je napravljen fajl adminoglasi.js u kom su hendleri za ovaj vju. Posto nije odmah prikazan ceo oglas vec samo glavna slika i osnovni podatci pa kad se ispod toga klikne
<h4>Ostali Podatci</h4> hendler skida atribut hidden divu koji je ispod u kom su svi podatci oglasa
Oglasi se prikazuju u adminoglasi.blade.php u dve kolone levo crvena u kojoj je 10 (ili koliko vec ima neodobrenih ako ih je manje od 10) neodobrenih i desno zelena kolona u -
-kojoj je 10 (ili koliko vec ima odobrenih ako ih je manje od 10) odobrenih. 
Kad se klikne na naslove kolona 'Neodobreni Oglasi' ili 'Odobreni Oglasi' preko rute '/adminoglasioilin/{oilin?}' se ide na metod adminoglasioilin( ) OglasControllera
Route::get('/adminoglasioilin/{oilin?}', 'OglasController@adminoglasioilin');
Metod vadi u zavisnosti da li je $oilin == 1 ili == 0 vadi (radi paginate(6)) odobrene ili neodobrene oglase i salje ih u vju adminoglasioilin.blade.php koji ih prikazuje
Vju adminoglasioilin.blad.php koji sam napravio u 'auto\resources\views\admin' prikazuje odobrene ili neodobrene oglase, ima na vrhu formu za pretragu odobrenih ili neodobren-
-ih oglasa (u zavisnosti sta je admin kliknuo u adminoglasi.blade.php tj da li je variabla $oilin koju vraca kontroler 1 ili 0) i na dnu je paginacija
Vju izgleda isto kao adminoglasi.blade.php tj imaju 2 kolone u kojoj se prikazuju oglasi samo sto su ovde samo odobreni ili neodobreni, i vju i metod adminoglasioilin( ) su zakom-
-entarisaani pa pogledaj, takodje vju ima js fajl adminoglasioilin.js u kom su hendleri za klikove na sve i svasta tj za odobravanje ili zabranjivanje oglasa, za prikazivanje svih poda
-taka oglasa, za otkrivanje forme za pretragu(tj skidanje atributa hidden divu u kom je forma), kad u formi user odabere marku ima hendler koji vadi sve modele marke kao u onim
-a za novioglas i izmenu oglasa, sortiranje izvadjenih oglasa tj promenu u selectu za sortiranje koji salje AJAX u metode adminoglasioilin( ) ili adminoglasipretraga( ) itd...
Takodje postoje 2 paginacije u adminoglasi.blade.php jedna ako je vju pozvan iz adminoglasioilin( ) a druga ako je radjen pretraga pa je pozvan iz adminoglasipretraga(  ), raz-
-lika je u tome sto ako je radjena pretraga na linkove za paginaciju se kace paramtri koji salju u adminoglasipretraga( ) sve ono sto je admin uneo u formu za pretragu
Forma za pretragu oglasa u adminoglasioilin.blade.php osim hidden polja u kom je $oilin 1 ili 2 (da bi kontroler znao koje oglase da pretrazi, odobrene ili neodobrene) ima polja 
-za Marku, Model, Gorivo, Godiste od i Godiste do, Poreklo i Kubikaza od i Kubikaza do
Kad se forma sabmituje ide preko rute '/adminoglaipretraga' na metod adminoglasipretraga( ) OglasControllera
//kad se u adminoglasioilin.blade.php sabmituje forma za pretragu odobrenih ili neodobrenih oglasa preko ove rute se gadja metod adminoglasipretraga() OglasControllera, 
//takodje se koristi kad se klikcu linkovi za paginaciju ako je vju vracen iz metoda adminoglasipretraga()
Route::get('/adminoglasipretraga', 'OglasController@adminoglasipretraga')->name('adminoglasipretraga');
Metod adminoglasipretraga( ) OglasControllera je prilicno zapetljan ali je zakomentarisan. On proverava sta je od polja za pretragu oglasa u adminoglaioilin.blade.php popunjeno
- i na osnovu toga pravi query i onda radi paginate(6) i vraca pronadjene oglase i ostale potrebne parametre u vju adminoglasioilin.blade.php 
U vjuu adminoglasioilin.blade.php prikazani oglasi se takodje mogu sortirati tj orderovati po raznim kolonama 'oglasis' tabele, za to postoji select iznad diva koji prikazuje oglase-
-ciji je hendeler u adminoglasioilin.js, on uzima sve parametre pretrage koji se nalaze u varijablama u vjuu i onda salje get ili metodu adminoglasioilin( ) ili metodu adminoglasipre-
-traga( ) sa pomenutim parametrima ali i salje parametre za sortiranje, pogledaj u adminoglasioilin.js, zakomentarisano je

FRONTEND

Radio na podesavanju prikaza userovih podataka u profil.js, novioglas.js i izmenioglas.js na malim ekranima, sada ako se na sajt dolazi sa malog ekrana podatci se ne prikazuju
-u tabeli posto lose izgleda nego se ona brise a umesto nje se ubacuje div koji malo bolje izgleda, to je na vrhovima tih fajlova.
Takodje sam u vjuove profil.blade.php, novioglas.blade.php i izmenioglas.blade.php na vrhu svakog dodao div #dpi koji je prazan a koriste ga js fajlovi da izmere sirinu ekrana

Napravio FrontController.php koji nece biti u auth middlewareu i izmenio rutu '/' da gadja index( ) FrontControllera koji vraca vju welcome.blade.php koji ce prikazivati najnovije-
-oglase, ruta
Route::get('/', 'FrontController@index');
index( ) metod ForntControllera vadi za sada 6 najnovijih odobrenih oglasa i salje ih u welcome.blade.php. Takodje salje ukupan broj odobrenih oglasa(to treba hendleru za kl-
-ik na h3 .naslovjosoglasa u welcome.js koji salje AJAX metodu josoglasa( ) FrontControllera koji izvlaci dodatne oglase za welcome.blade.php) i salje sve marke da bi bio pop-
-punjen select za marku u formi za pretragu oglasa koja je na vrhu welcome.blade.php vjua. index( ) metod FrontControllera je zakomentarisan, pa pogledaj
Prepravljam vju welcome.blade.php, vju ce pri ucitavanju sajta prikazati 6 najnovijih oglasa, ispod njih je h3 .naslovjosoglasa koji kad se klikne ucitava jos 6 oglasa(to radi hend
-ler u welcome.js tako sto preko rute '/josoglasa' salje AJAX metodu josoglasa( ) FrontControllera) i moze se kliktati dok ne ucita sve oglase iz 'oglasis' tabele tj dok var skip ne-
- bude jednaka ili veca od vrednosti variable ukupnooglasa koju je poslao index( ) metod FrontControllera, tada se uklanja h3 .naslovjosoglasa
I hendler u welcome.js i josoglasa( ) FrontControllera su zakomentarisani
U welcome.js takodje postoji i funkcija FileExist(urlToFile) koja proverava da li postoji odredjena slika koju koristi ovaj hendler kad prikazuje oglase da bi pri prikazivanju naslovne 
-slike oglasa proverio koja slika je prva po redu tj postoji u folderu za slike oglasa koji se prikazuje, zakomentarisano je 
Na vrhu welcome.blade.php je h3 .naslovpretraga koji kad se klikne prikazuje formu za pretragu ispod njega koja inace ima hidden='true' tj to radi hendler za klik na taj h3 koji je
- u welcome.js
( sama foma se nalazi u fajlu formapretraga.blade.php u folderu 'auto\resources\views\forma' koju @include-ujem u vju-ove welcome.blade.php i rezpretrage)
Ovo je osnovna pretaga i ima polja Marka, Model, Gorivo, Godiste od, Godiste do, Cena od, Cena do, Karoserija, Kubikaza od, Kubikaza do i Prikazi ostecene , zatim ima btn
za submit i za Detaljnu pretragu koji kad se klikne prikazuje ostala polja u formi za pretragu koja su u div-u .detaljnapretraga koji je hidden ali kad se klikne ovaj btn onda hendler
-u welcome.js uklanja taj atribut i div .detaljnapretraga tj ostatak forme za pretragu oglasa postaje vidljiv. U tom delu forme su polja Emisiona klasa, Snaga od i Snaga do, Kilometr
-aza od i Kilometraza do, Pogon, Menjac, Br vrata, Br sedista, Strana volana, Klima, Boja, Poreklo, zatim checkbox-ovi koji su podeljeni u sekcije Sigurnost, Oprema i Stanje
Da ne bih navodio sve isto je kao u formi za upload novog oglasa ili izmenu postojeceg
Pravim GET rutu '/frontpretraga' koja gadja metod pretraga( ) FrontControllera 
Route::get('/frontpretraga', 'FrontController@pretraga')->name('frontpretraga');
Metod pretraga( ) FrontControllera prvo proverava koja polja u formi za pretragu odobrenih oglasa su popunjena, i zatim u zavisnosti od toga sta je popunjeno pravi se query
-za 'oglasis' tabelu koji pre svega ima where('odobre', 1) a zatim pomocu Laravelog metoda when( ) u zavisnosti sta je popunjeno u formi kalemi na to ostale WHERE-ove, na 
-kraju dodaje i orderBy koji je po difoltu po koloni created_at 'oglasis' tabele ali user u rezpretrage.blade.php moze u selectu odabrati neku drugu kolonu i ASC ili DESC i na sa
-mom kraju qury-a je za sada paginate(4)
Kad izvadimo oglase u variablu oglasi, pozivamo vju rezpretrage.blade.php koji pravim u 'auto\resources\views' koji ce prikazivati izvucene oglase useru i imace na vrhu opet
-istu formu za pretragu koja ce ovoga puta vec biti popunjena onim sto je user uneo u formu za pretragu u welcome.blade.php ( sama foma se nalazi u fajlu 
 - formapretraga.blade.php u folderu 'auto\resources\views\forma' koju @include-ujem u vju rezpretrage) i zato iz metoda pretraga( ) saljemo u rezpretrage.blade.php saljemo 
-u variablama istoimenim sa imenima polja pretrage vrednosti koje su stigle iz forme da bi mogli da u rezpretrage.blade.php kad crtamo novu formu mogli da -
-proverimo da li je polje bilo popunjeno i kojom vrednoscu, takodje ove variable su potrebne pri pravljenju linkova za paginaciju posto na linkove treba nakalemiti parametre pret-
-rage da bi kad se klikne link paginacije koji takodje poziva metod pretraga( ) FrontControllera  opet poslao iste parametre
(ovo je povelik metod pa ga necu kopirati ali je zakomentarisan pa pogledaj)
Vju rezpretrage.blade.php za sada na vrhu ima istu formu kao i welcome.blade.php (isto je sakrivena dok se ne klikne h3 .naslovpretraga a hendler koji ga otkriva je u rezpretra
-ge.js), jedina razzlika je u tome sto je ova forma vec popunjena unosom u formu u welcome.blade.php pa posto su stigli parametri iz metoda pretraga( ) FrontControllera to je -
-izvodljivo 
Ispod forme je prikaz oglasa koji su pronadjeni u bazi i linkovi za paginaciju na koje su nakalemljeni parametri pretrage koje je takodje poslao metod pretraga( )FrontControllera
da bi kad se klikne neki link od paginacije primio iste parametre
-iznad oglasa je select za sortiranje oglasa, moze se sortirati po datumu postavljanja silazno ili uzlazno (created_at kolona ASC ili Desc), godistu ASC ili DESC, ceni ASC ili
-DESC i kubikazi ASC ili DESC, Kad se nesto od ovoga odaberere u selectu za sortiranje poziva se hendler iz rezpretrage.js koji pravi url sa istim parametrima pretage salje
-request metodu pretraga( ) FrontControllera sa novi sort i ascdesc parametrima
Takodje svaki prikazan oglas u rezpretrage.blade.php je link ka oglas.blade.php tj ka ruti '/oglas/{oglasid?}' tj ka metodu prikazioglas( ) FrontControllera na koji takodje kacim sve
-parametre pretrage i takodje $sort i $ascdesc koju je user odabrao da bi i u oglas.blade.php forma vec bila popunjena unetim parametrima pa user moze onda da ide u detaljn-
-iju pretragu
PRIKAZ JEDNOG OGLASA
U folderu 'auto\resources\views' pravim vju oglas.blade.php koji ce prikazivati jedan oglas i hendlere za njega u fajlu oglas.js u folderu 'auto\public\js\autojq'
Njega poziva metod prikazioglas( ) FrontControllera. U requestu mu stizu i svi parametri eventualne pretrage(osim ako nije kliknuto na neki oglas u welcome.blade.php jer to
-znaci da forma za pretragu nije sabmitovana) i on ih prosledjuje u vju zajedno sa oglasom ciji je id stigao u requestu da bi forma za pretragu bila popunjena(zakomentarisano je)
Prvo radim na prikazu slika oglasa, to je div  .row col-md-6 levo paddinglevodesno (prvi ispod forme, ovaj vju takodje ima include-ovanu formu za pretragu oglasa tj vju forma.bl
-ade.php i metod prikazioglas( ) FrontControllera mu salje sve parametre koje je user uneo u formu i sort i ascdesc(tj da li je sortirao rezultate petrage u rezpretrage.blade.php)-
-tako da ako hoce da nastavi da suzava pretragu ne mora da se vraca u welcome.blade.php ili rezpretrage.blade.php)
U divu se na vrhu prikazuje glavna slika oglasa(tj prva slika oglasa tj slika kojoj je ime najmanji broj, posto tu vrti for petlja do 12 i gleda da li u folderu za slike oglasa postoji slika
-koja se zove 1 pa 2 pa 3 itd i kad naleti na prvu prikaze je i radi break;). Na glavnoj slici postoje ikone tj strelice za levo i desno tj za prethodnu i sledecu sliku koje su skrivene dok
-user ne hoveruje po slici misem, takodje one postoje samo ako oglas ima vise od jedne slike, njihovi hendleri su u oglas.js(hendler u oglas.js je zakomentarisan pa pogledaj)
Ispod glavne slike tj div-a .divnaslovnaslikaspoljni je div .row col-md-12 maleslike paddinglevo u kom se prikazuju thumbovi tj male slike ostalih slika oglasa koje kad klinemo, ta -
-koju smo kliknuli postaje glavna tj hendler iz oglas.js menja src atribut glavne slike da pokazuje ka imenu neke od malih slika koju smo kliknuli(zakomentarisano je u oglas.js)
Takodje mala slika koja je trenutno glavna dobija klasu opacity tj zamagljena je da bi user znao da je to slika koja se trenutno prikazuje(hendler u oglas.js je zakomentarisan) 
Pored ikona za levo i desno na naslovno slici je i lupa za zoom tj za ulazak u galeriju slika (ona takodje ima hidden koji se uklanja na hover naslovne slike), na vrhu oglas.blade-
-.php je div .ceoekran koji je hidden i u kom se prikazuje galerija(on kad izgubi atribut hiden pokriva ceo ekran), hendleri za ovo sve su u oglas.js i zakomentarisano je, kad se -
-udje u galeriju i tu se slike strelicama koje generise oglas.js mogu pomerati tj menjati levo i desno tj nazad i napred, sve radi oglas.js u kom su i hendleri za ove strelice, takodje
-se slike u galeriji mogu menjati i skrolovanjem tockica na misu, hendler za ovo je takodje u oglas.js
Pored diva .levo u kom je naslovna i malenaslovne slike su div-ovi .desnoprvi i .desnodrugi
U desnoprvi su na vrhu kao naslov cena vozila i osnovni podatci vozila(tj obavezna polja u formi za novi oglas), u .desnodrugi su na vrhu ako ima logo prodavca i ime i ispod li-
-nk za sve njegove oglase ( zbog toga menjao i metod pretraga( ) FrontControllera koji sada proverava da li je stigao u requestu id korisnika(tj oglasivaca) cije oglase user zeli da
- vidi i ako jeste onda vadi samo oglase tog oglasivaca, takodje menjan je i rezpretrage.blade.php(pogotovu linkovi i  paginacija i takodje i rezpretrage.js posto on hendluje 
-promenu sortranja oglasa i dodao sam  sortiranje po broju pregleda oglasa)), zatim su tu ostali podatci oglasivaca tj kontakt telefon(vju proverava da li ima vise od jednog telefo-
-na i ako ima prikazuje ih i proverava da li oglasivac zeli vidljiv email na oglasu)
Ispod ovih div-ova je div .ispod koji prikazuej kolone oprema, sigurnost, stanje i tekst 'oglasis' tabele, tj sta je oglasivac cekirao u tim sekcijama u novioglas.blade.php i unos u -
-textarea za tekst oglasa
Ispod svega u oglas.blade.php proverava se da li su popunjene kolone lat, lng i zoom 'users' tabele (kod usera ciji se oglas prikazuje) i ako jesu postoji div .map koji ce prikaza-
-ti google map tj lokaciju oglasivaca. Mapu prikazuje oglas.js i postavlja marker na tacnu lokaciju koju je oglasivac kliknuo na mapi u profil.blade.php pri editovanju profila


Takodje sam prepravljao i dodajmerku.blade.php tako da sada kad se unose novi modeli marke MarkaController tj metod storemodel( ) vraca i ime marke kojoj smo dodali model
- i logo i id marke pa sada forma za unos modela ostaje otvorena i polje za marku je popunjeno markom kojoj smo malopre dodali model pa se ne mora pri unosu svakog modela
-ponovo birati i marka
















